# -*- coding: utf-8 -*-
from transformers import AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig
import torch
# 配置量化参数

quantization_config = BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_quant_type="nf4",
    bnb_4bit_use_double_quant=True,
    bnb_4bit_compute_dtype=torch.float16
)

# model_name = "/Users/ailabuser7-1/Documents/cursor-workspace/qwen-2.5-coder-finetune/finetuning/sft/checkpoints/sft_model/7B"
model_name = "/Users/ailabuser7-1/Documents/cursor-workspace/qwen-2.5-coder-finetune/finetuning/sft/merged_models/32B"

# 加载模型
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    torch_dtype=torch.float16,
    device_map="auto",
    use_cache=False,
    #quantization_config=quantization_config
)

print("Model dtype:", model.dtype)
print("Model device:", model.device)
print("Parameters device:", next(model.parameters()).device)
print("First parameter dtype:", next(model.parameters()).dtype)
print("Model config dtype:", model.config.torch_dtype)

tokenizer = AutoTokenizer.from_pretrained(model_name)

prompt = '''请分析并增强以下 API 的元数据信息。基于提供的原始信息和 Java 方法代码片段。特别注意：在分析请求体和响应时，请保留原始Java类名作为类型（如UserDTO、OrderRequest等），而不要简单地用"object"替代： 原始 API 信息： - Asset ID: afe65b67-6a83-4f8d-a9b7-513d2778e03a\n- 名称 (Name): VoucherSendController_afterSendVoucherProcess\n- 业务域 (Business Domain): ft\n- 路径 (Path): /send/test/afterSendVoucherProcess\n- 方法 (Method): POST\n- 描述 (Description): afterSendVoucherProcess\n- 原始请求参数: [{"in":"body","name":"jsonObject","description":"","type":"JSONObject","inRequestBody":true,"required":true,"isRequestBody":true}]\n- 原始请求体: {"schema":{"description":"Schema based on Java type: JSONObject","type":"object"},"description":"Request body of type JSONObject","paramName":"jsonObject","contentType":"application/json","coreType":"JSONObject"}\n- 原始响应: [{"schema":{},"description":"无内容","coreType":"void","statusCode":"204"}]\n- 原始关系: []\n- 原始 LogicInfo: {"purpose":"Handle POST requests for /send/test/afterSendVoucherProcess","scope":"API Endpoint","executionContext":"Server-side"}\n Java 方法代码片段： ```java // 主方法: afterSendVoucherProcess @ControllerLogger @PostMapping("/test/afterSendVoucherProcess") @ApiOperation(value = "凭证发送成功后处理") public void afterSendVoucherProcess(@RequestBody JSONObject jsonObject) { userEnvService.getLocalSession().setIgnoreAllTable(true); String accVoucherLogId = jsonObject.getString("accVoucherLogId"); VoucherInformFssDTO voucherInformFssDTO = jsonObject.getObject("voucherInformFssDTO", VoucherInformFssDTO.class); voucherSendService.afterSendVoucherProcess(accVoucherLogId, voucherInformFssDTO); } // 依赖方法: recordInvoiceAccountStatus public void recordInvoiceAccountStatus(String accVoucherLogId) { AccVoucherLog accVoucherLog = accVoucherLogMapper.selectById(accVoucherLogId); AccVoucher accVoucher = accVoucherMapper.selectById(accVoucherLog.getVoucherId()); /** * 非费用凭证 */ if (!ConvertUtils.PRE_VOUCHER_TYPE_EXPENSE.equals(accVoucher.getPreVoucherType())) { accVoucherLogService.updateInvoiceAccountStatus(RegularUtils.INVOICE_ACCOUNT_STATUS_WITHOUT_DEAL, accVoucherLog.getVoucherId()); return; } /** * 发票明细中是否含有增值税发票的行 * 低代码获取共享工单发票明细 */ Boolean havaAddTaxInvoice = false; AccModel scVoucherModel = accModelService.getByFormId("sc_voucher"); //单据表单数据 FormDataDTO scVoucherFormDataDTO = accModelService.getFormData(scVoucherModel, accVoucher.getConvertBillId()); List<Map<String, Object>> invoiceDetailList = scVoucherFormDataDTO.getTableData().get(ConvertUtils.SC_VOUCHER_INVOICE_DETAIL).getData(); for (Map<String, Object> invoiceDetail : invoiceDetailList) { if (VatInvoiceTypeList.contains(invoiceDetail.get("type"))) { havaAddTaxInvoice = true; } } if (!havaAddTaxInvoice) { accVoucherLogService.updateInvoiceAccountStatus(RegularUtils.INVOICE_ACCOUNT_STATUS_WITHOUT_DEAL, accVoucherLog.getVoucherId()); return; } /** * 根据凭证是否冲销凭证，更新发票记账状态 */ String voucherType = RegularUtils.getVoucherSourceType(accVoucher.getCode()); if (RegularUtils.VOUCHER_SOURCE_WRITE_OFF.equals(voucherType)) { accVoucherLogService.updateInvoiceAccountStatus(RegularUtils.INVOICE_ACCOUNT_STATUS_WAIT_CANCEL, accVoucherLog.getVoucherId()); }else{ accVoucherLogService.updateInvoiceAccountStatus(RegularUtils.INVOICE_ACCOUNT_STATUS_WAIT_ACCOUNT, accVoucherLog.getVoucherId()); } } // 依赖方法: updateInvoiceAccountStatus public void updateInvoiceAccountStatus(String invoiceAccountStatus, String voucherId) { LambdaUpdateWrapper<AccVoucherLog> updateWrapper = new LambdaUpdateWrapper<AccVoucherLog>(); updateWrapper .set(AccVoucherLog::getInvoiceAccountStatus, invoiceAccountStatus) .eq(AccVoucherLog::getIsDeleted, false) .eq(AccVoucherLog::getVoucherId, voucherId); accVoucherLogMapper.update(null, updateWrapper); } // 依赖方法: getByFormId public AccModel getByFormId(String formId){ LambdaQueryWrapper<AccModel> queryWrapper = new LambdaQueryWrapper<AccModel>() .eq(AccModel::getType,"0") .eq(AccModel::getFormId, formId) .eq(AccModel::getIsEnabled, true); List<AccModel> dataList = accModelMapper.selectList(queryWrapper); if (CollectionUtils.isEmpty(dataList)){ throw new ExceptionData(ErrorCode.BUSINESS_ERROR.code(), String.format("表单%s未在模型中定义，请先定义！", formId)); } if (dataList.size() > 1){ throw new ExceptionData(ErrorCode.BUSINESS_ERROR.code(), String.format("表单%s在模型中定义了多次，请检查数据！", formId)); } return dataList.get(0); } // 依赖方法: getFormData public FormDataDTO getFormData(AccModel accModel, String formInstanceId){ String srcSystem = accModel.getSrcSystem(); String formId = accModel.getFormId(); Optional<AccModelProcessor> optional = Optional.ofNullable(accModelProcessorMap.get(srcSystem)); AccModelProcessor processor = optional.orElseThrow(() -> new ExceptionData(-1, String.format("系统%s表单%s未定义，请检查！", srcSystem, formId))); return processor.getFormData(formId, formInstanceId); } // 依赖方法: recordArchiveStatus public void recordArchiveStatus(String accVoucherLogId) { AccVoucherLog accVoucherLog = accVoucherLogMapper.selectById(accVoucherLogId); if (!ConvertUtils.FORM_ID_ACC_ADJUST.equals(accVoucherLog.getSrcFormId())) { return; } LambdaUpdateWrapper<AccVoucherLog> accVoucherLogLambdaUpdateWrapper = new LambdaUpdateWrapper<AccVoucherLog>(); accVoucherLogLambdaUpdateWrapper .set(AccVoucherLog::getArchiveStatus, RegularUtils.ARCHIVE_STATUS_WAIT) .eq(AccVoucherLog::getId, accVoucherLogId); accVoucherLogMapper.update(null, accVoucherLogLambdaUpdateWrapper); } // 依赖方法: generateInstructBill public void generateInstructBill(String scBillId) { log.info("展台摊销-指令单生成开始,scBillId:{}", scBillId); ScVoucher scVoucher = scVoucherService.getScVoucher(scBillId); if (!scVoucher.getIsApportion()) { return; } AccVoucherLog accVoucherLog = accVoucherLogMapper.selectByScBillId(scBillId); if (Objects.isNull(accVoucherLog)) { return; } Date sendTime = accVoucherLog.getSendTime(); //计算初始摊销日期 Date startAmortizeDate = accVoucherService.getStartAmortizeDate(scBillId); List<ScReconciliation> reconciliationList = scReconciliationService.getReconciliationList(scBillId); for (ScReconciliation scReconciliation : reconciliationList) { try { BigDecimal instructAmount = scReconciliation.getAmortizeAmount(); AccBoothInstructBill accBoothInstructBill = new AccBoothInstructBill(); accBoothInstructBill.setId(ConvertFunction.uuid()); accBoothInstructBill.setInstructBillCode(scReconciliation.getInstructCode()); accBoothInstructBill.setApplyBillCode(scReconciliation.getApplyBillCode()); accBoothInstructBill.setPaymentBillCode(scReconciliation.getDetailBillId()); accBoothInstructBill.setReimbBillCode(scVoucher.getReimbBillCode()); accBoothInstructBill.setOrderCode(scVoucher.getCode()); accBoothInstructBill.setCompanyCode(scVoucher.getPayCompanyId()); accBoothInstructBill.setCompanyName(scVoucher.getPayCompanyName()); accBoothInstructBill.setExpenseCode(scVoucher.getExpenseId()); accBoothInstructBill.setStoreCode(scReconciliation.getStoreCode()); accBoothInstructBill.setStoreName(scReconciliation.getStoreName()); accBoothInstructBill.setIndustryCode(scReconciliation.getIndustryCode()); accBoothInstructBill.setIndustryName(scReconciliation.getIndustryName()); accBoothInstructBill.setBrandCode(scReconciliation.getBrandCode()); accBoothInstructBill.setBrandName(scReconciliation.getBrandName()); accBoothInstructBill.setInstructAmount(instructAmount); accBoothInstructBill.setServiceLife(scReconciliation.getServiceLife()); accBoothInstructBill.setStartVaildDate(scReconciliation.getStartValidDate()); accBoothInstructBill.setDisposeDate(scReconciliation.getDisposeDate()); accBoothInstructBill.setSystemSource(scVoucher.getSystemCode()); accBoothInstructBill.setType("FT"); accBoothInstructBill.setDeptCode(scVoucher.getHandlerDeptId()); accBoothInstructBill.setDeptName(scVoucher.getHandlerDeptName()); accBoothInstructBill.setStartAmortizeDate(startAmortizeDate); //使用期限 int serviceLife = Integer.parseInt(scReconciliation.getServiceLife()); List<AccBoothAmortizeBill> accBoothAmortizeBillList = new ArrayList<>(); //月度摊销金额 BigDecimal monthAmount = instructAmount.divide(new BigDecimal(serviceLife), 2, RoundingMode.HALF_UP); //特殊场景处理: 当开始使用日期所在月份<工单对应凭证的凭证发送日期所在月份，第一笔摊销单的月度摊销金额=月度摊销金额 * （初始摊销月份 – 开始使用月份） int months = 0; Date startVaildDate = Date.from(accBoothInstructBill.getStartVaildDate().atStartOfDay(ZoneId.systemDefault()).toInstant()); if (startVaildDate.compareTo(sendTime) < 0) { Calendar calendar = Calendar.getInstance(); calendar.setTime(startVaildDate); int startMonth = calendar.get(Calendar.MONTH); int startYear = calendar.get(Calendar.YEAR); calendar.setTime(startAmortizeDate); int amortizeMonth = calendar.get(Calendar.MONTH); int amortizeYear = calendar.get(Calendar.YEAR); //初始摊销月份–开始使用月份 months = (amortizeYear - startYear) * 12 + amortizeMonth - startMonth; if (months > 0) { serviceLife = serviceLife - months + 1; } } BigDecimal totalAmount = BigDecimal.ZERO; for (int i = 1; i <= serviceLife; i++) { AccBoothAmortizeBill accBoothAmortizeBill = new AccBoothAmortizeBill(); accBoothAmortizeBill.setId(ConvertFunction.uuid()); accBoothAmortizeBill.setInstructId(accBoothInstructBill.getId()); accBoothAmortizeBill.setInstructBillCode(accBoothInstructBill.getInstructBillCode()); accBoothAmortizeBill.setAmortizeBillCode(ConvertFunction.createDJBH("acc_booth_amortize_bill_sn", "acc_booth_amortize_bill", "amortize_bill_code")); accBoothAmortizeBill.setCompanyCode(accBoothInstructBill.getCompanyCode()); accBoothAmortizeBill.setCompanyName(scVoucher.getPayCompanyName()); accBoothAmortizeBill.setServiceLife(accBoothInstructBill.getServiceLife()); accBoothAmortizeBill.setDeptCode(accBoothInstructBill.getDeptCode()); accBoothAmortizeBill.setExpenseId(accBoothInstructBill.getExpenseCode()); accBoothAmortizeBill.setBillType(scVoucher.getBillTypeId()); accBoothAmortizeBill.setPaymentBillCode(scReconciliation.getDetailBillId()); accBoothAmortizeBill.setReimbBillCode(scVoucher.getReimbBillCode()); accBoothAmortizeBill.setIsFirst(i==1); //计算摊销月度 Calendar calendar = Calendar.getInstance(); calendar.setTime(startAmortizeDate); calendar.add(Calendar.MONTH, i - 1); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM"); accBoothAmortizeBill.setPeriod(sdf.format(calendar.getTime())); //特殊场景第一笔金额处理 if (i == 1 && months > 0) { accBoothAmortizeBill.setAmount(monthAmount.multiply(new BigDecimal(months))); } else if (i == serviceLife) {//最后一笔摊销金额处理尾差 //accBoothAmortizeBill.setAmount(instructAmount.subtract(monthAmount.multiply(new BigDecimal(serviceLife - 1)))); accBoothAmortizeBill.setAmount(instructAmount.subtract(totalAmount)); } else { accBoothAmortizeBill.setAmount(monthAmount); } totalAmount = totalAmount.add(accBoothAmortizeBill.getAmount()); accBoothAmortizeBillList.add(accBoothAmortizeBill); } this.insertInstructBill(accBoothInstructBill, accBoothAmortizeBillList); } catch (Exception e) { String content = "展台摊销-摊销单出现异常,scBIllCode:" + scReconciliation.getScBillCode(); this.sendEmail(content, "ZTTX-TEMPLATE-02"); } } } // 依赖方法: getScVoucher public ScVoucher getScVoucher(String scBillId) { return scVoucherMapper.selectList(new LambdaQueryWrapper<ScVoucher>().eq(ScVoucher::getId,scBillId)).get(0); } // 依赖方法: getStartAmortizeDate public Date getStartAmortizeDate(String convertBillId) { return accVoucherMapper.getStartAmortizeDate(convertBillId); } // 依赖方法: getReconciliationList public List<ScReconciliation> getReconciliationList(String scBillId) { return scReconciliationMapper.selectList(new LambdaQueryWrapper<ScReconciliation>().eq(ScReconciliation::getScBillId,scBillId)); } ``` 请执行以下任务： 1. **验证和精炼描述 (Description):** 基于代码逻辑，验证或提供一个更准确、更详细的功能描述。 2. **细化请求/响应 Schema:** 如果原始信息中的 Schema (RequestBody/Responses) 较为通用，尝试根据方法代码推断更具体的字段、类型和约束 (例如，JSON Schema 格式)。特别注意：对于请求体(RequestBody)参数的类型，必须使用代码中定义的实际Java类名（如UserDTO、OrderRequest等），而不是简单地用"object"替代。这些类型名称对于API文档的准确性至关重要。 3. **推断/验证参数 (RequestParams):** 基于方法签名和代码体内的使用，识别或验证路径参数、查询参数，并提供名称、类型、是否必需和描述。 4. **验证/发现关系 (Relationships):** 检查原始关系列表中的关系是否在代码中可循证（例如，方法调用了某个服务）。识别代码中明显的、但原始列表中缺失的调用关系（例如，调用其他服务或组件），并按原始关系的格式补充。 5. **优化 LogicInfo:** 根据代码上下文，提供或改进 `logicInfo`，说明其用途、范围等。 6. **整理业务规则:** 根据整理的代码上下文，梳理具体的业务规则作为描述的补充内容放入description的值中。业务规则需尽量详细，包括但不限于逻辑时序、状态转移、条件判断、数据（到具体字段）处理、调用关系，并使用mermaid流程图。 7. **分析业务领域 (businessDomain):** 基于API的功能、参数和代码逻辑，概括出API所属的真实业务领域，而不是直接使用代码包路径。例如，对于用户注册API，业务领域应为"用户管理"或"账户服务"，而不是"com.example.user"。请在JSON响应的businessDomain字段中提供这个概括的业务领域名称。 请同时分析代码中的业务规则： 请确保： 1. 规则ID要唯一且有意义 2. 规则优先级使用 HIGH/MEDIUM/LOW 3. 规则类型使用 验证规则/定价规则/审批规则/业务规则 4. condition和action要基于实际代码逻辑 5. 变量要包含代码中使用的关键对象 6. 规则关系要反映实际的执行顺序和依赖关系 请将API增强结果和业务规则提取结果合并到一个JSON对象(包含assetApi和assetRules两个子对象)中返回。 请遵循以下JSON结构： ```json { "assetApi": { "assetId": "唯一标识符", "assetType": "资产类型(PAGE/LOGIC/DATA)", "assetSubType": "资产子类型", "name": "资产名称", "description": "业务描述", "version": "资产版本(SemVer)", "status": "资产状态(DRAFT/REVIEWED/PUBLISHED/ARCHIVED)", "tags": ["标签1", "标签2"], "businessDomain": "业务域", "createdInfo": { "creator": "创建者", "createdAt": "创建时间", "source": "来源(MANUAL/EXTRACTED/GENERATED)" }, "modifiedInfo": { "lastModifier": "最后修改者", "lastModifiedAt": "最后修改时间" }, "relationships": [ { "targetAssetId": "目标资产ID，如果目标资产类型是DATA或者匹配不到，则使用目标资产的包路径填充", "targetAssetType": "目标资产类型", "relationshipType": "关系类型(DEPENDS_ON/DERIVED_FROM/CALLS/READS/WRITES/VALIDATES/等)", "direction": "关系方向(OUTGOING/INCOMING)", "description": "关系描述" } ], "logicInfo": { "purpose": "逻辑用途", "scope": "作用范围", "executionContext": "执行上下文" }, "content": { "api": { "path": "API路径", "method": "HTTP方法", "description": "API描述", "requestParams": [ { "name": "参数名称", "type": "参数类型", "required": "是否必须", "description": "参数描述" } ], "requestBody": { "contentType": "内容类型", "schema": "请求体结构，必须使用原始Java类名作为类型，而不是简单地标记为object" }, "responses": [ { "statusCode": "状态码", "description": "响应描述", "schema": "响应结构，同样必须使用原始Java类名作为返回类型，而不是简单地标记为object" } ] } } }, "assetRules": { "assetId": "<规则集唯一标识>", "assetType": "LOGIC", "assetSubType": "RULE_SET", "name": "<规则集名称>", "description": "<规则集描述>", "version": "<版本号>", "status": "<状态>", "tags": ["<标签1>", "<标签2>"], "businessDomain": "<业务领域>", "createdInfo": { "creator": "<创建者>", "createdAt": "<创建时间>", "source": "<来源>" }, "modifiedInfo": { "lastModifier": "<最后修改者>", "lastModifiedAt": "<最后修改时间>" }, "relationships": [ { "targetAssetId": "<目标资产ID>", "targetAssetType": "<目标资产类型>", "relationshipType": "<关系类型>", "direction": "<方向>", "description": "<关系描述>" } ], "ruleInfo": { "domain": "<规则领域>", "category": "<规则类别>", "priority": "<优先级策略>", "executionMode": "<执行模式>" }, "content": { "rules": [ { "id": "<规则ID>", "name": "<规则名称>", "description": "<规则描述>", "priority": "<优先级>", "category": "<规则类型>", "condition": "<条件表达式>", "action": "<满足条件执行动作>", "elseAction": "<不满足条件执行动作>", "attributes": { "complexity": "<复杂度>", "implementationType": "<实现类型>", "sourceSystem": "<来源系统>" } } ], "ruleRelationships": [ { "sourceRuleId": "<源规则ID>", "targetRuleId": "<目标规则ID>", "relationshipType": "<关系类型>", "description": "<关系描述>" } ], "variables": [ { "name": "<变量名>", "type": "<变量类型>", "description": "<变量描述>" } ] } } } ``` /no think
'''
messages = [
    {"role": "system", "content": "你是一个专业的代码专家，精通Java、Python、Go、Vue等多种编程语言。\n你擅长代码审查、调试和优化，能够提供高质量的代码建议和解决方案。\n你的回答总是准确、专业且易于理解。"},
    {"role": "user", "content": prompt}
]
text = tokenizer.apply_chat_template(
    messages,
    tokenize=False,
    add_generation_prompt=True
)

# 在生成输入之前添加这些检查
tokens = tokenizer.encode(text)
print(f"输入文本的Token数量: {len(tokens)}")
#print(f"Token列表: {tokenizer.convert_ids_to_tokens(tokens)}")  # 显示具体的tokens

# 生成输入
model_inputs = tokenizer([text], return_tensors="pt").to(model.device)
print(f"输入张量形状: {model_inputs.input_ids.shape}")

generated_ids = model.generate(
    **model_inputs,
    max_new_tokens=4096,
    use_cache=False
)
generated_ids = [
    output_ids[len(input_ids):] for input_ids, output_ids in zip(model_inputs.input_ids, generated_ids)
]

response = tokenizer.batch_decode(generated_ids, skip_special_tokens=True)[0]
print(f"response: \n{response}")